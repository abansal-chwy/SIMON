package markov;
 
 
 
 
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
 
import org.apache.commons.csv.*;
import org.apache.commons.math3.distribution.*;
import org.apache.commons.math3.util.*;
import org.jgrapht.graph.*;
 
public class train {
    //we first locate the input files generated by parsing the JSON files 
    private static final String EVENT_SEQUENCES = "E:\\SUNY\\Research\\Projects\\Simon\\src\\markov\\transition_matrix.txt";
    private static final String USER_COLLBORATION = "E:\\SUNY\\Research\\Projects\\Simon\\src\\markov\\userGraph.csv";
    private static final String REPO_ACTIVTY_PRIOR = "E:\\SUNY\\Research\\Projects\\Simon\\src\\markov\\Repo_activity.csv";
    private static final String USER_ACTIVTY_PRIOR = "E:\\SUNY\\Research\\Projects\\Simon\\src\\markov\\user_activity.csv";
     
     
     
    private DefaultDirectedWeightedGraph<String, DefaultWeightedEdge> eventGraph;
    private DefaultDirectedWeightedGraph<Integer, DefaultWeightedEdge> userGraph;
    private EnumeratedDistribution<Integer> repoPriori;
    private EnumeratedDistribution<String> eventPriori;
    private EnumeratedDistribution<Integer> userPriori;
     
     
    public train() throws IOException
    {
    prepareEventGraph();
    prepareRepoPriori();
    prepareUserGraph();
    prepareUserPriori();
    }
    /*
     * following methods are the needed getters to get the estimated parameters after training them
     */
    public DefaultDirectedWeightedGraph<String, DefaultWeightedEdge> getEventGraph() {
        return eventGraph;
    }
     
    public DefaultDirectedWeightedGraph<Integer, DefaultWeightedEdge> getUserGraph() {
        return userGraph;
    }
    
    public EnumeratedDistribution<Integer> getRepoPriori() {
        return repoPriori;
    }
    
    public EnumeratedDistribution<String> getEventPriori() {
        return eventPriori;
    }
     
    public EnumeratedDistribution<Integer> getUserPriori() {
        return userPriori;
    }
     
    /*
     * followings are helper methods for training the parameters based on the found data 
     */
     
    private void prepareEventGraph () throws IOException
    {
        //The following hardcoded event int map would be updated based on the number of events we read from the file in future 
        HashMap<String, Integer> events = new HashMap<String, Integer>() {{
            put("CreateEvent",0);
            put("PushEvent", 1);
            put("PullRequestEvent", 2);
            put("DeleteEvent", 4);
            put("IssuesEvent",3);
            put("PullRequestReviewCommentEvent", 5);
            put("ForkEvent", 6);
            put("WatchEvent", 7);
            put("IssueCommentEvent", 8);
            put("CommitCommentEvent", 9);
            put("GollumEvent", 10);
            put("MemberEvent", 11);
            put("ReleaseEvent", 12);
            put("PublicEvent", 13);
            put("RestEvent", 14);
        }};
        
       HashMap<Integer, String> eventsReverse = new HashMap<Integer, String>() {{
            put(0, "CreateEvent");
            put(1, "PushEvent");
            put(2, "PullRequestEvent");
            put(4, "DeleteEvent");
            put(3, "IssuesEvent");
            put(5, "PullRequestReviewCommentEvent");
            put(6, "ForkEvent");
            put(7, "WatchEvent");
            put(8, "IssueCommentEvent");
            put(9, "CommitCommentEvent");
            put(10, "GollumEvent");
            put(11, "MemberEvent");
            put(12, "ReleaseEvent");
            put(13, "PublicEvent");
            put(14, "RestEvent");
        }};
         
        eventGraph = new DefaultDirectedWeightedGraph<String, DefaultWeightedEdge>
            (DefaultWeightedEdge.class);
         
        //adding the desired events as the vertices of the graph
        for (String string : events.keySet())
        {
        eventGraph.addVertex(string);
        }
         
        int[][] counts = new int[events.size()][events.size()];    
        int[] outDegree = new int[events.size()];     
         
         
          
          BufferedReader br = Files.newBufferedReader(Paths.get(EVENT_SEQUENCES));
          
          String st;
          while ((st = br.readLine()) != null)
          {
              String[] sequence =  st.split(",");
              for(int i =0; i< sequence.length-1 ; i++)
              {
           String first = sequence[i].trim().replaceAll("\'","");
           //System.out.println(first);
           String second = sequence[i+1].trim().replaceAll("\'","");
           //System.out.println(second);
             int p =  events.get(first);
             //System.out.println(p);
             int q = events.get(second);
             //System.out.println(q);
             counts[p][q]++;
             //System.out.println(counts[p][q]);
             outDegree[p]++;
             //System.out.println(outDegree[p]);
              }
          }
            for (int i = 0; i < events.size(); i++)  {
         
                // Print probability for column j. 
                for (int j = 0; j < events.size(); j++) {
                        double p;
                        if(counts[i][j] == 0 || outDegree[i] ==0)
                        {
                         p = 0;
                         System.out.printf("%7.2f ", p*100);
                        }
                        else {
 
                         p = counts[i][j]*1.0/outDegree[i];
 
                         System.out.printf("%7.2f ", p*100);
                        }
                        //System.out.println(p);
                    eventGraph.setEdgeWeight(eventGraph.addEdge(eventsReverse.get(i), eventsReverse.get(j)), p); 
                }
                System.out.println();
            }
             
     prepareEventPriori(counts, eventsReverse);
             
             
    }
     
    private void prepareUserGraph () throws IOException
    {
        try (
                Reader reader = Files.newBufferedReader(Paths.get(USER_COLLBORATION));
                CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT);
            ) {
                Iterable<CSVRecord> csvRecords = csvParser.getRecords();
                 
                userGraph = new DefaultDirectedWeightedGraph<Integer, DefaultWeightedEdge>
                (DefaultWeightedEdge.class);
                 
                //we first add the vertices
                for (CSVRecord record: csvRecords)
                {
                        userGraph.addVertex(Integer.valueOf(record.get(0)));
//                      if(!userGraph.containsVertex(Integer.valueOf(record.get(1))))
//                          userGraph.addVertex(Integer.valueOf(record.get(1)));
                }
                 
                //and now we add weights for the inserted vertices
                for (CSVRecord record: csvRecords)
                {
                    if(Double.valueOf(record.get(2)) == null || Integer.valueOf(record.get(0)) == null || Integer.valueOf(record.get(1)) == null)
                {continue;}
                else {
                //System.out.println("us1 "+ Integer.valueOf(record.get(0)));
                //System.out.println("us2 "+ Integer.valueOf(record.get(0)));
                     userGraph.setEdgeWeight(userGraph.addEdge(Integer.valueOf(record.get(0)), Integer.valueOf(record.get(1))), 
                             Double.valueOf(record.get(2)));
                }
                }
            }
    }
     
    private void prepareRepoPriori () throws IOException
    {
        List<Pair<Integer, Double>> listOfprobs = new ArrayList<>();
        try (
                Reader reader = Files.newBufferedReader(Paths.get(REPO_ACTIVTY_PRIOR));
                CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT);
                ) {
            Iterable<CSVRecord> csvRecords = csvParser.getRecords();
             
            for(CSVRecord records : csvRecords)
            {
                listOfprobs.add(new Pair<>(Integer.valueOf(records.get(0)),Double.valueOf(records.get(1))));
            }
            repoPriori = new EnumeratedDistribution<>(listOfprobs);
         }
    }
     
    /**
     * 
     * @param counts is the count of events following each other being computed by parsing the event sequence file
     * and is being read in PrepareEventGraph 
     */
    private void prepareEventPriori (int[][] counts, HashMap<Integer, String> eventReverse)
    {
    int[] rowSum = new int[counts.length];
    int total = 0;
     
    //count of each event is the sum of row
    for (int i=0; i < counts.length ; i++)
    {
        for (int j = 0 ; j <counts[0].length ; j++ )
        {
        rowSum[i] += counts[i][j];
        total += counts[i][j];
        }
    }
     
    List<Pair<String, Double>> listOfprobs = new ArrayList<>();
    for(int i =0; i< rowSum.length; i++)
    {
        listOfprobs.add(new Pair<>(eventReverse.get(i), rowSum[i]*1.0/total));
    }
    //System.out.println(listOfprobs.size());
    eventPriori = new EnumeratedDistribution<>(listOfprobs);
     
    }
     
     
    private void prepareUserPriori () throws IOException
    {
            List<Pair<Integer, Double>> listOfprobs = new ArrayList<>();
            try (
                Reader reader = Files.newBufferedReader(Paths.get(USER_ACTIVTY_PRIOR));
                CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT);
                ) {
            Iterable<CSVRecord> csvRecords = csvParser.getRecords();
 
            for(CSVRecord records : csvRecords)
            {
                listOfprobs.add(new Pair<>(Integer.valueOf(records.get(0)),Double.valueOf(records.get(1))));
            }
            userPriori = new EnumeratedDistribution<>(listOfprobs);
        }
    }
     
     
}